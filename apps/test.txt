/* -*- c++ -*- */
/*
 * Copyright 2009 Free Software Foundation, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Implements the quadradio control active object.
 *
 * The networking stack and the top-level control resides in this object.
 *
 * We read UDP command packets from VRT_UDP_CTRL_PORT, send replies
 * from VRT_UDP_CTRL_PORT, and when asked to stream data, send that
 * from VRT_UDP_DATA_PORT.
 */



#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "qpn_port.h"
#include "bsp.h"
#include "qpn_vrt_server.h"
#include "bpmgr.h"
#include "port_reader.h"
#include <vrt/if_context.h>
#include <vrt/types.h>
#include <nonstdio.h>
#include "lcd.h"
#include "kludge_net.h"

#include <vrt/server_ports.h>
#include <vrt/bits.h>


#include <memory_map.h>
#include <pic.h>

#include "memory_map.h"
#include "spi.h"
#include "hal_io.h"
#include "buffer_pool.h"
#include "pic.h"
#include <stdbool.h>
#include "ethernet.h"
#include "default_ethno.h"
#include "nonstdio.h"
#include "memcpy_wa.h"
#include "ip.h"
#include "ethertype.h"
#include "if_arp.h"
#include "ads62p4x.h"
#include "lsdac.h"
#include "hal_uart.h"
#include "banal.h"
#include <udp_burner_packet.h>
#include <arp_cache.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include "qr_db.h"


#define VERBOSE 0		// define to 0 or 1



/* LED assignments */

#define	LED_LINK0_UP		0x1
#define	LED_LINK1_UP		0x2


#define	QR_VRT_HLEN_NLINES	5	// # of 32-bit items in VRT header
#define	QR_VRT_TLEN_NLINES	1	// # of 32-bit items in VRT trailer


/* local objects ---------------------------------------------------------- */


// # of packets we send with each cmd queue entry
#define PKTS_PER_CMD	2

typedef struct rx_state_tag
{
  size_t	    nbytes_per_sample;	// # of bytes in a sample (4 or 16)

  // State for streaming mode
  bool 		    streaming_p;  	// are we streaming?
  uint32_t 	    samples_per_pkt;  	// # of samples / pkt.  
  uint32_t	    streaming_pkt_count;

} rx_state_t;

typedef struct control_tag {
  QActive    super;		 // extend the QActive class
  rx_state_t rx_state[2];        // info for the two RX DSP pipes

  bool        gps_locked;
  bool        lo_locked;
  bool        cal_locked;
  vrt_temp_t  caldiv_temp;

} control;	// the control active object;

static struct sockaddr_in streaming_dst;


static QState control_initial(control *me);
static QState control_active (control *me);


static void 
control_handle_eth_packet(control *me, int ethno, int bufno, size_t nbytes);

void
handle_vrt_control_packet(struct sockaddr_in src, struct sockaddr_in dst,
			  unsigned char *payload, int payload_len);

static void
send_ctrl_pkt(void *id, void *data, size_t data_len);

static void half_band_init(void);
static void beam_former_init(void);

static void update_trailer(control *me);
static void send_context(control *me);
  
// Allocate the structure that holds the concatenation of
// all of the context packets that we ever send.

#define IFC_HDR   (VRTH_PT_IF_CONTEXT | VRTH_TSI_UTC | VRTH_TSF_SAMPLE_CNT)
#define IFC_SIZE(name) (sizeof(name)/sizeof(uint32_t))

static all_context_t all_context = {

  .beamformer.cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.beamformer),
  .beamformer.cntx_hdr.stream_id = QR_SID_BEAMFORMER_IF_CNTX,
  .beamformer.cntx_hdr.context_indicator = 
     CI_CHANGE_INDICATOR | CI_RF_REF_FREQ | CI_SAMPLE_RATE | CI_PAYLOAD_FMT,

  .beamformer.rf_ref_freq = 0,
  .beamformer.sample_rate = 0,
  .beamformer.format = {DF0_16_BIT_IQ, DF1_VECTOR_1},

  .db[0].cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.db[0]),
  .db[0].cntx_hdr.stream_id = QR_SID_DBOARD_0_IF_CNTX,
  .db[0].cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_GAIN,

  .db[1].cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.db[0]),
  .db[1].cntx_hdr.stream_id = QR_SID_DBOARD_1_IF_CNTX,
  .db[1].cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_GAIN,

  .db[2].cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.db[0]),
  .db[2].cntx_hdr.stream_id = QR_SID_DBOARD_2_IF_CNTX,
  .db[2].cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_GAIN,

  .db[3].cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.db[0]),
  .db[3].cntx_hdr.stream_id = QR_SID_DBOARD_3_IF_CNTX,
  .db[3].cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_GAIN,

  // FIXME add the extension context
  .caldiv.cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.caldiv),
  .caldiv.cntx_hdr.stream_id = QR_SID_CALDIV_IF_CNTX,
  .caldiv.cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_TEMPERATURE,

  .gps.cntx_hdr.header = IFC_HDR | IFC_SIZE(all_context.gps),
  .gps.cntx_hdr.stream_id = QR_SID_GPS_IF_CNTX,
  .gps.cntx_hdr.context_indicator = CI_CHANGE_INDICATOR | CI_FORMATTED_GPS,
};

// Point to the header in each context packet
static if_context_hdr_t *cntx_hdr[NCONTEXT_PKTS] = {
  &all_context.beamformer.cntx_hdr,
  &all_context.db[0].cntx_hdr,
  &all_context.db[1].cntx_hdr,
  &all_context.db[2].cntx_hdr,
  &all_context.db[3].cntx_hdr,
  // FIXME add the extension context
  &all_context.caldiv.cntx_hdr,

  &all_context.gps.cntx_hdr,
};

//snapshot of the time when eth last chance got a data packet
static sr_time64_t last_sr_time64;

/* global objects -------------------------------------------------------- */

control AO_control;
vrt_formatted_gps_t *vrt_gps_info = &all_context.gps.formatted_gps;

/* ----------------------------------------------------------------------- */
void 
control_ctor(void)
{
  control *me = &AO_control;
  QActive_ctor(&me->super, (QStateHandler) &control_initial);

  me->rx_state[0].nbytes_per_sample = 1 * sizeof(uint32_t); // 1x (16-bit I & Q)
  me->rx_state[0].streaming_p = false;
  me->rx_state[0].samples_per_pkt = 0;
  me->rx_state[0].streaming_pkt_count = 0;

  me->rx_state[1].nbytes_per_sample = 4 * sizeof(uint32_t); // 4x (16-bit I & Q)
  me->rx_state[1].streaming_p = false;
  me->rx_state[1].samples_per_pkt = 0;
  me->rx_state[1].streaming_pkt_count = 0;

  // FIXME init additional state here
}

/* utilities ------------------------------------------------------------- */

static void 
handle_uart_input(unsigned uart)
{
  int ch;

  while ((ch = hal_uart_getc_nowait(uart)) >= 0){
    hal_uart_putc(uart, ch);	// FIXME echo...
  }

  // unmask the uart rx interrupt to allow more URX_AVAIL_SIG msgs to be generated
  bsp_reenable_uart_rx_irq(uart);
}

/* HSM definition -------------------------------------------------------- */
QState
control_initial(control *me)		// top-most initial transition
{
  if (1)
    putstr("\nqpn_vrt_server: control\n\n");

  //ethernet_register_link_changed_callback(link_changed_callback);
  //link0_is_up = true;

  ethernet_init();
  arp_cache_init();
  beam_former_init();
  half_band_init();

  for (int e = 0; e < ethernet_ninterfaces(); e++){
    printf("eth%d\n", e);
    putstr("  IP: ");
    print_ip(ethernet_ip_addr(e));
    newline();
  
    putstr("  MAC: ");
    print_mac_addr(ethernet_mac_addr(e)->addr);
    newline();
  }

  /*for (int i = 0; i < 4; i++){
    printf("db%d\n", i);
    qr_db_set_revision(i, i | 0x0100);
    printf("  RevNo %x\n", qr_db_get_revision(i));
    qr_db_set_serial(i, i | 0x0200);
    printf("  SerNo %x\n", qr_db_get_serial(i));
    qr_db_set_model(i, i | 0x0300);
    printf("  ModNo %x\n", qr_db_get_model(i));
  }*/

  register_udp_listener(VRT_UDP_CTRL_PORT, handle_vrt_control_packet);
  register_udp_listener(VRT_UDP_BURNER_PORT, handle_udp_burner_packet);

  return Q_TRAN(&control_active);
}

QState
control_active(control *me)
{
  //printf("control_active: Q_SIG() = %d\n", Q_SIG(me));

  //the ui may be interested! forward all signals to the ui
  if (Q_SIG(me) != ETH_PACKET_AVAIL_SIG)
    QActive_post((QActive *) &AO_ui, Q_SIG(me), Q_PAR(me));

  switch(Q_SIG(me)){

  case URX_AVAIL_SIG:
    handle_uart_input(Q_PAR(me));
    return Q_HANDLED();

  //---- GPS Handling ------------------------------------------------//
  case GPS_FAILURE_SIG:
    me->gps_locked = false;
    update_trailer(me);
    if (VERBOSE) printf("Control Active: GPS FAIL %d\n", low32(Q_PAR(me)));
    return Q_HANDLED();

  case GOT_GPS_FIX_SIG:
    me->gps_locked = low32(Q_PAR(me));
    update_trailer(me);
    send_context(me);
    if (VERBOSE) printf("Control Active: GOT_GPS_FIX %d\n", low32(Q_PAR(me)));
    return Q_HANDLED();

  case NO_GPS_FIX_SIG:
    me->gps_locked = false;
    update_trailer(me);
    if (VERBOSE) printf("Control Active: NO_GPS_FIX\n");
    return Q_HANDLED();

  //---- CalDiv Handling ---------------------------------------------//
  case UPDATE_LO_LOCK_SIG:
    all_context.caldiv.lo_locked = Q_PAR(me);
    me->lo_locked = Q_PAR(me);
    update_trailer(me);
    return Q_HANDLED();

  case UPDATE_CAL_LOCK_SIG:
    all_context.caldiv.cal_locked = Q_PAR(me);
    me->cal_locked = Q_PAR(me);
    return Q_HANDLED();

  case UPDATE_CAL_ENB_SIG:{
    uint8_t enb = Q_PAR(me);
    send_ctrl_pkt("cal_enb", &enb, sizeof(enb));
    return Q_HANDLED();
  }

  case UPDATE_CALDIV_REV_SIG:{
    uint32_t num = Q_PAR(me);
    send_ctrl_pkt("caldiv_rev", &num, sizeof(num));
    return Q_HANDLED();
  }

  case UPDATE_CALDIV_SER_SIG:{
    uint32_t num = Q_PAR(me);
    send_ctrl_pkt("caldiv_ser", &num, sizeof(num));
    return Q_HANDLED();
  }

  case UPDATE_CALDIV_MOD_SIG:{
    uint32_t num = Q_PAR(me);
    send_ctrl_pkt("caldiv_mod", &num, sizeof(num));
    return Q_HANDLED();
  }

  case UPDATE_CAL_FREQ_SIG:{
    vrt_freq_t freq = Q_PAR(me);
    send_ctrl_pkt("cal_freq", &freq, sizeof(freq));
    return Q_HANDLED();
  }

  case UPDATE_LO_FREQ_SIG:{
    all_context.beamformer.rf_ref_freq = Q_PAR(me);
    send_context(me); //immediate message to host
    vrt_freq_t freq = Q_PAR(me);
    send_ctrl_pkt("lo_freq", &freq, sizeof(freq));
    return Q_HANDLED();
  }

  case UPDATE_CALDIV_TEMP:
    all_context.caldiv.temp = Q_PAR(me);
    me->caldiv_temp = Q_PAR(me);
    return Q_HANDLED();

  case CALDIV_FAILURE_SIG:
    me->lo_locked = false;
    me->cal_locked = false;
    update_trailer(me);
    if (VERBOSE) printf("Control Active: CALDIV FAIL %d\n", low32(Q_PAR(me)));
    return Q_HANDLED();

  //---- Eth Handling ------------------------------------------------//
  case ETH_PACKET_AVAIL_SIG:
    {
      size_t nbytes = high32(Q_PAR(me));
      int ethno = (low32(Q_PAR(me)) >> 8) & 0xff;
      int bufno = low32(Q_PAR(me)) & 0xff;
      control_handle_eth_packet(me, ethno, bufno, nbytes);
      return Q_HANDLED();
    }
    
  } // Q_SIG(me)

  //return Q_SUPER(&QHsm_top);
  return QQ_HSM_TOP();
}


static void 
update_trailer(control *me)
{
  uint32_t t = TR_ENABLE(TR_CAL_TIME | TR_REF_LOCK | TR_AGC);

  if (me->gps_locked)
    t |= TR_STATE(TR_CAL_TIME);
  if (me->lo_locked)
    t |= TR_STATE(TR_REF_LOCK);

  // we're always in manual gain control mode

  sr_rx_ctrl[0].vrt_trailer = t;
  sr_rx_ctrl[1].vrt_trailer = t;
}

static uint32_t
incr_pkt_cnt(uint32_t header)
{
#if 1
  int t = (header + (1 << VRTH_PKT_CNT_SHIFT)) & VRTH_PKT_CNT_MASK;
  header = (header & ~VRTH_PKT_CNT_MASK) | t;
#endif
  return header;
}

static void
send_context(control *me)
{
  // alloc buffer
  // update context packet counters
  // copy to buffer
  // enqueue buffer

  printf("send_context\n");
  //return;

#if 0
  // FIXME if this fails, set a timer and try again in 1 tick,
  // or better yet, add an additional state (wait_for_buffer)
  // and do the right thing.
  int bufno = bpmgr_low_pri_alloc(0);
  
  if (bufno < 0){
    hal_uart_putc_nowait(UART_MAIN, 'B');  // FIXME failed to allocate buffer
    // FIXME start timer or better fix
    return;
  }
#endif

  //bool include_gps_packet = me->gps_locked;
  //The gps has useful information when its not locked
  //So I am sending the gps packet every time
  bool include_gps_packet = true;
  
  int npkts = include_gps_packet ? NCONTEXT_PKTS : NCONTEXT_PKTS - 1;
  for (int i = 0; i < npkts; i++){
    cntx_hdr[i]->header = incr_pkt_cnt(cntx_hdr[i]->header);
    cntx_hdr[i]->integer_secs = last_sr_time64.secs;
    cntx_hdr[i]->fractional_secs = make64(last_sr_time64.ticks, 0);
  }

  size_t nbytes = include_gps_packet ? SIZEOF_ALL_CONTEXT : SIZEOF_ALL_CONTEXT_BUT_GPS;
  send_udp_pkt(VRT_UDP_DATA_PORT, streaming_dst,
	       &all_context, nbytes);
}


/* Gory details of packet inspection, etc -------------------------------- */

/*
 * Examine incoming ethernet packets and see if they're for the firmware.
 * On the quadradio, they are all for the firmware.  The only question
 * is do we immediately handle it, or send a message to an AO to handle it.
 *
 * This is called in an interrupt context.  Don't spend much time here...
 */
inspector_result_t
eth_inspector(void *arg, unsigned bufno, size_t nbytes)
{
  int ethno = (int) arg;

  QActive_postISR((QActive *) &AO_control, ETH_PACKET_AVAIL_SIG,
		  make64(nbytes, ((ethno & 0xff) << 8) | (bufno & 0xff)));

  return INS_WILL_HANDLE_IN_TASK;
}

/*
 * Examine VRT packets from DSP pipeline just before they are
 * forwarded to the ethernet and patch as required.
 */
void
vrt_touch_up(void *arg, unsigned bufno, size_t nbytes)
{
  int rxdspno = (int) arg;

  // Patch fast path UDP packet length into control word.
  buffer_ram(bufno)[0] = 0x10000 | nbytes;	// fast path

  // Patch VRT header length field (number of 32-bit words).
  // (It's the low 16-bits in the header)
  uint32_t vrt_header = buffer_ram(bufno)[1];
  vrt_header &= ~VRTH_PKT_SIZE_MASK;
  vrt_header |= (nbytes / sizeof(uint32_t)) & VRTH_PKT_SIZE_MASK;
  buffer_ram(bufno)[1] = vrt_header;


  // Keep streaming happening
  
  // Queue up another rx command when required
  if (AO_control.rx_state[rxdspno].streaming_p
      && --AO_control.rx_state[rxdspno].streaming_pkt_count == 0){
    AO_control.rx_state[rxdspno].streaming_pkt_count = PKTS_PER_CMD;
    sr_rx_ctrl[rxdspno].time_ticks = 0;	// enqueue another command
  }
}

/*
 * called just before we start transfering a buffer to ethernet
 */
static void
eth_last_chance(unsigned bufno)
{
    //extract the header and test its type for data
    uint32_t vrt_header = buffer_ram(bufno)[1];
    if ((vrt_header & VRTH_PT_MASK) == VRTH_PT_IF_DATA_NO_SID ||
        (vrt_header & VRTH_PT_MASK) == VRTH_PT_IF_DATA_WITH_SID){
        // if VRT IF-Data packet, remember timestamp
        memcpy(&last_sr_time64, sr_time64, sizeof(sr_time64_t));
    }
}

void
control_run_port_reader_ctors(void)
{
  /*
   * Setup both ethernet readers so that they can handle all incoming traffic
   */
  port_reader_ctor(FSM_port_reader[PORT_ETH0],
		   PORT_ETH0, 0,	// src_port, first_line_recv
		   0, 0,		// dst_port, first_line_send
		   eth_inspector, 0,
		   port_reader_nop_touch_up, (void *) 0,
		   0);

  port_reader_ctor(FSM_port_reader[PORT_ETH1],
		   PORT_ETH1, 0,	// src_port, first_line_recv
		   0, 0,		// dst_port, first_line_send
		   eth_inspector, (void *) 1,
		   port_reader_nop_touch_up, (void *) 0,
		   0);

  /*
   * By default, route DSP0 and DSP1 to ETH0
   */
  port_reader_ctor(FSM_port_reader[PORT_DSP0],
		   PORT_DSP0, 1,	// src_port, first_line_recv
		   PORT_ETH0, 0,	// dst_port, first_line_send
		   port_reader_nop_inspector, (void *) 0,
		   vrt_touch_up, (void *) 0,
		   eth_last_chance);

  port_reader_ctor(FSM_port_reader[PORT_DSP1],
		   PORT_DSP1, 1,	// src_port, first_line_recv
		   PORT_ETH0, 0,	// dst_port, first_line_send
		   port_reader_nop_inspector, (void *) 1,
		   vrt_touch_up, (void *) 1,
		   eth_last_chance);
}

// ------------------------------------------------------------------------

static void 
control_handle_eth_packet(control *me, int ethno, int bufno, size_t nbytes)
{
  if (0){
    printf("\neth_pkt: eth = %d, bufno = %d, nbytes = %d\n",
	   ethno, bufno, nbytes);
    print_bytes(0, (unsigned char *)buffer_ram(bufno), nbytes);
  }

  // call kludge_net input function
  handle_eth_packet(ethno, buffer_ram(bufno), (nbytes + 3)/4);

  bpmgr_free(bufno);
}

// ------------------------------------------------------------------------
//             Reworked guts of original vrt_server
//
// This should probably all be revisited, but that's left for another day.
// ------------------------------------------------------------------------


static volatile bool link0_is_up = false;	// eth handler sets this
static volatile bool link1_is_up = false;	// eth handler sets this


// ------------------------------------------------------------------------


void
txp_set_mac_dst(int ethno, const eth_mac_addr_t *m)
{
  sr_txp[ethno].r[2] = (m->addr[0] << 8) | m->addr[1];
  sr_txp[ethno].r[3] = (m->addr[2] << 8) | m->addr[3];
  sr_txp[ethno].r[4] = (m->addr[4] << 8) | m->addr[5];
}

void
txp_set_mac_src(int ethno, const eth_mac_addr_t *m)
{
  sr_txp[ethno].r[5] = (m->addr[0] << 8) | m->addr[1];
  sr_txp[ethno].r[6] = (m->addr[2] << 8) | m->addr[3];
  sr_txp[ethno].r[7] = (m->addr[4] << 8) | m->addr[5];
}

static void
init_tx_protocol_engine(int ethno,
			const eth_mac_addr_t *dst_mac_addr,
			struct in_addr dst_ip_addr_,
			int udp_src_port,
			int udp_dst_port)
{
  // init tx protocol engine
  unsigned int chksum = 0;
  txp_set_mac_dst(ethno, dst_mac_addr);
  txp_set_mac_src(ethno, ethernet_mac_addr(ethno));
  uint32_t src_ip_addr = ethernet_ip_addr(ethno).s_addr;
  uint32_t dst_ip_addr = dst_ip_addr_.s_addr;
  sr_txp[ethno].r[8]  = ETHERTYPE_IPV4;		    // IP ether typetype
  sr_txp[ethno].r[9]  = CHKSUM(0x4500, &chksum);    // IPV4,  5 words of header (20 bytes), TOS=0
  sr_txp[ethno].r[10] = TXP_INS_IP_LEN;             // Don't checksum this line in SW
  sr_txp[ethno].r[11] = CHKSUM(0x0000, &chksum);    // ID
  sr_txp[ethno].r[12] = CHKSUM(0x4000, &chksum);    // don't fragment
  sr_txp[ethno].r[13] = CHKSUM(0x2011, &chksum);    // TTL=32, protocol = UDP (17 decimal)
  // sr_txp[ethno].r[14] = checksum 		    // see below
  sr_txp[ethno].r[15] = CHKSUM(src_ip_addr >> 16, &chksum);    // IP src high
  sr_txp[ethno].r[16] = CHKSUM(src_ip_addr & 0xffff, &chksum); // IP src low
  sr_txp[ethno].r[17] = CHKSUM(dst_ip_addr >> 16, &chksum);    // IP dst high
  sr_txp[ethno].r[18] = CHKSUM(dst_ip_addr & 0xffff, &chksum); // IP dst low
  sr_txp[ethno].r[14] = TXP_INS_IP_HDR_CHKSUM | (chksum & 0xffff);
  sr_txp[ethno].r[19] = udp_src_port & 0xffff;
  sr_txp[ethno].r[20] = udp_dst_port & 0xffff;
  sr_txp[ethno].r[21] = TXP_INS_UDP_LEN;
  sr_txp[ethno].r[22] = TXP_LAST_WORD;		// zero UDP checksum
}

// ------------------------------------------------------------------------

void
restart_streaming(int rxdspno)
{
  //dbsm_stop(&dsp0_rx_sm);

  // setup RX DSP regs
  sr_rx_ctrl[rxdspno].clear_overrun = 1;  // reset

  AO_control.rx_state[rxdspno].streaming_p = true;
  AO_control.rx_state[rxdspno].streaming_pkt_count = PKTS_PER_CMD;

  sr_rx_ctrl[rxdspno].cmd =
    MK_RX_CMD(PKTS_PER_CMD * AO_control.rx_state[rxdspno].samples_per_pkt,
	      1, 1);		// set "now" and "chain" bits

  // kick off the state machine
  //dbsm_start(&dsp0_rx_sm);

  sr_rx_ctrl[rxdspno].time_secs = 0;	
  sr_rx_ctrl[rxdspno].time_ticks = 0;	// enqueue first of two commands

  // make sure this one and the rest have the "now" and "chain" bits set.
  sr_rx_ctrl[rxdspno].cmd =
    MK_RX_CMD(PKTS_PER_CMD * AO_control.rx_state[rxdspno].samples_per_pkt,
	      1, 1);		// set "now" and "chain" bits

  sr_rx_ctrl[rxdspno].time_secs = 0;	
  sr_rx_ctrl[rxdspno].time_ticks = 0;	// enqueue second of two commands
}

void 
stop_streaming(int rxdspno)
{
  if (AO_control.rx_state[rxdspno].streaming_p){
    AO_control.rx_state[rxdspno].streaming_p = false;	// will stop streaming w/in 2*PKTS_PER_CMD packets
    
    // no samples, "now", not chained
    sr_rx_ctrl[rxdspno].cmd = MK_RX_CMD(0, 1, 0);

    sr_rx_ctrl[rxdspno].time_secs = 0;	
    sr_rx_ctrl[rxdspno].time_ticks = 0;	// enqueue command
  }
}

void
stop_all_streaming(void)
{
  stop_streaming(0);
  stop_streaming(1);
}

void
rx_streaming_cmd(int rxdspno, bool on_p,
		 struct in_addr dst_ip, int dst_port,
		 size_t samples_per_pkt)
{
  printf("\nrxs_cmd: rxdspno %d\n", rxdspno);

  if (!on_p){
    stop_streaming(rxdspno);
    printf("stop\n");
    return;
  }

  streaming_dst = make_sockaddr_in(dst_ip, dst_port);

#if 0
  size_t mtu = 1500;		
  size_t max_words_per_pkt =
    ((mtu - IP_HLEN - UDP_HLEN)/sizeof(uint32_t)
     - QR_VRT_HLEN_NLINES - QR_VRT_TLEN_NLINES);	// 362
#else
  size_t mtu = 8192;		
  size_t max_words_per_pkt =
    ((mtu - IP_HLEN - UDP_HLEN)/sizeof(uint32_t)
     - QR_VRT_HLEN_NLINES - QR_VRT_TLEN_NLINES);	// 2035
#endif

  // FIXME if we go to something smaller than 16-bit I & Q
  size_t words_per_sample = AO_control.rx_state[rxdspno].nbytes_per_sample / sizeof(uint32_t);
  size_t max_samples_per_pkt = max_words_per_pkt / words_per_sample;

  if (samples_per_pkt == 0 || samples_per_pkt > max_samples_per_pkt)
    samples_per_pkt = max_samples_per_pkt;

  int vrt_pkt_size_nlines =
    QR_VRT_HLEN_NLINES + QR_VRT_TLEN_NLINES + samples_per_pkt;

  eth_mac_addr_t dst_mac;
  bool found = arp_cache_lookup_mac(&dst_ip, &dst_mac);
  if (!found){
    printf("vrt_server: failed to hit cache looking for ");
    print_ip(dst_ip);
    newline();
    AO_control.rx_state[rxdspno].streaming_p = false;
    return;
  }

  //int src_port = dynamic_port_alloc();
  int src_port = VRT_UDP_DATA_PORT;
  init_tx_protocol_engine(DEFAULT_ETHNO, &dst_mac, dst_ip,
			  src_port, dst_port);

  sr_rx_ctrl[rxdspno].vrt_header =
    (0
     | VRTH_PT_IF_DATA_WITH_SID
     | VRTH_HAS_TRAILER
     | VRTH_TSI_GPS
     | VRTH_TSF_SAMPLE_CNT
     | vrt_pkt_size_nlines);

  sr_rx_ctrl[rxdspno].vrt_stream_id = QR_SID_BEAMFORMER_IF_DATA;
  //sr_rx_ctrl[rxdspno].vrt_trailer = 0x55555555;
  update_trailer(&AO_control);

  printf("samples/pkt = %d\n", samples_per_pkt);
  sr_rx_ctrl[rxdspno].nsamples_per_pkt = samples_per_pkt;

  sr_rx_ctrl[0].nchannels = 1; //FIXME find me a better home
  sr_rx_ctrl[1].nchannels = 4; //FIXME find me a better home

  AO_control.rx_state[rxdspno].samples_per_pkt = samples_per_pkt;
  restart_streaming(rxdspno);		// enqueue the commands
}

// ------------------------------------------------------------------------

#if 0
/*
 * Called when eth phy state changes (w/ interrupts disabled)
 */
void
link_changed_callback(int ethno, int speed)
{
  ethno &= 0x1;
  if (ethno == 0){
    link0_is_up = speed == 0 ? false : true;
    //hal_set_leds(link0_is_up ? 0x2 : 0x0, 0x2);
  }
  else {
    link1_is_up = speed == 0 ? false : true;
    //hal_set_leds(link1_is_up ? 0x2 : 0x0, 0x2);
  }

  printf("\neth link[%d] changed: speed = %d\n", ethno, speed);
}
#endif

// ------------------------------------------------------------------------


#include "ctrl_pkt.h"
#include "qr_init.h"

#define	_AL4 __attribute__((aligned (4)))
#define CTRL_VERBOSE false

static struct sockaddr_in ctrl_dst;

static void
send_ctrl_pkt(void *id, void *data, size_t data_len){
    //pack the data and id into the payload
    uint8_t payload[100] _AL4; size_t payload_len;
    ctrl_pkt_pack(id, data, data_len, payload, &payload_len);
    //pad the length in bytes to a word-multiple
    payload_len += (sizeof(uint32_t)-payload_len%sizeof(uint32_t))%sizeof(uint32_t);
    send_udp_pkt(VRT_UDP_CTRL_PORT, ctrl_dst, payload, payload_len);
    if (CTRL_VERBOSE) printf("Sent id %s (%d)\n", id, data_len);
}

/*static*/ void
handle_vrt_control_packet(struct sockaddr_in src, struct sockaddr_in dst,
			  unsigned char *payload, int payload_len)
{
    ctrl_dst = src; //always reload the ctrl destination
    void *id, *data;
    size_t data_len;
    ctrl_pkt_unpack(&id, &data, &data_len, payload, payload_len);
    if (data == NULL){
        printf("Error: Bad Control Packet\n");
        return;
    }
    if (data && CTRL_VERBOSE) printf("Got id %s (%d)\n", id, data_len);
    if (ctrl_pkt_id_cmp(id, "echo")){
        send_ctrl_pkt(id, data, data_len);
        return;
    }
    //------------- handlers for the cal div control -------------------//
    if (ctrl_pkt_id_cmp(id, "lo_freq")){
        if (data_len) QActive_post((QActive *) &AO_caldiv, SET_LO_FREQ_SIG, get_int64(data));
        else          QActive_post((QActive *) &AO_caldiv, GET_LO_FREQ_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "cal_freq")){
        if (data_len) QActive_post((QActive *) &AO_caldiv, SET_CAL_FREQ_SIG, get_int64(data));
        else          QActive_post((QActive *) &AO_caldiv, GET_CAL_FREQ_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "cal_enb")){
        if (data_len) QActive_post((QActive *) &AO_caldiv, SET_CAL_ENB_SIG, get_int8(data));
        else          QActive_post((QActive *) &AO_caldiv, GET_CAL_ENB_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "caldiv_rev")){
        QActive_post((QActive *) &AO_caldiv, GET_CALDIV_REV_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "caldiv_ser")){
        QActive_post((QActive *) &AO_caldiv, GET_CALDIV_SER_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "caldiv_mod")){
        QActive_post((QActive *) &AO_caldiv, GET_CALDIV_MOD_SIG, 0);
        return;
    }
    if (ctrl_pkt_id_cmp(id, "lo_locked")){
        send_ctrl_pkt(id, &AO_control.lo_locked, sizeof(uint8_t));
        return;
    }
    if (ctrl_pkt_id_cmp(id, "cal_locked")){
        send_ctrl_pkt(id, &AO_control.cal_locked, sizeof(uint8_t));
        return;
    }
    if (ctrl_pkt_id_cmp(id, "caldiv_temp")){
        send_ctrl_pkt(id, &AO_control.caldiv_temp, sizeof(AO_control.caldiv_temp));
        return;
    }
    //------------- handlers for the qr control -------------------//
    if (ctrl_pkt_id_cmp(id, "beamforming") && data_len == sizeof(uint32_t)*8){
        for (int i = 0; i < 4; i++){
            int32_t i_gain = get_int32(data + (i*2 + 0)*sizeof(uint32_t));
            int32_t q_gain = get_int32(data + (i*2 + 0)*sizeof(uint32_t));
            printf("Loading beamforming taps %d + %dj\n", i_gain, q_gain);
            sr_beam_former->input[i].i_gain = i_gain;
            sr_beam_former->input[i].q_gain = q_gain;
        }
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    if (ctrl_pkt_id_cmp(id, "mem32") && data_len == sizeof(uint32_t)*2){
        int addr = get_int32(data);
        int value = get_int32(data + sizeof(uint32_t));
        *((uint32_t *) addr) = value;	// Don't complain to me when you blow your foot off ;-)
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    if (ctrl_pkt_id_cmp(id, "setting_reg") && data_len == sizeof(uint32_t)*2){
        int regno = get_int32(data + 0*sizeof(uint32_t)) & 0xff;    // 256 32-bit wr-only regs
        int value = get_int32(data + 1*sizeof(uint32_t));
        //printf("Regno %d, val %x\n", regno, value);
        ((uint32_t *)_SR_ADDR(0))[regno] = value;
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    if (ctrl_pkt_id_cmp(id, "qr_rev")){
        uint32_t num = qr_get_revision();
        send_ctrl_pkt(id, &num, sizeof(num));
        return;
    }
    if (ctrl_pkt_id_cmp(id, "qr_ser")){
        uint32_t num = qr_get_serial();
        send_ctrl_pkt(id, &num, sizeof(num));
        return;
    }
    if (ctrl_pkt_id_cmp(id, "qr_mod")){
        uint32_t num = qr_get_model();
        send_ctrl_pkt(id, &num, sizeof(num));
        return;
    }
    //------------- handlers for the db control -------------------//
    if (ctrl_pkt_id_cmp(id, "hsadc_conf") && data_len == sizeof(uint32_t)*3){
        int db_mask = get_int32(data + 0*sizeof(uint32_t));
        int regno = get_int32(data + 1*sizeof(uint32_t));
        int value = get_int32(data + 2*sizeof(uint32_t));
        for (int i = 0; i < 4; i++){
            if (db_mask & (1 << i)){
                ads62p4x_safe_write_reg(i, regno, value);
            }
        }
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    if (ctrl_pkt_id_cmp(id, "lsdac") && data_len == sizeof(uint32_t)*3){
        int db_mask = get_int32(data + 0*sizeof(uint32_t));
        int which_dac = get_int32(data + 1*sizeof(uint32_t));
        int value = get_int32(data + 2*sizeof(uint32_t));
        for (int i = 0; i < 4; i++){
            if (db_mask & (1 << i)){
                lsdac_write(i, which_dac, value);
            }
        }
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    if (ctrl_pkt_id_cmp(id, "dboard_pins") && data_len == sizeof(uint32_t)*2){
        int db_mask = get_int32(data + 0*sizeof(uint32_t));
        int value = get_int32(data + 1*sizeof(uint32_t));
        for (int i = 0; i < 4; i++){
            if (db_mask & (1 << i)){
                sr_dbctrl[i].ctrl = value;
            }
        }
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    //------------- handlers for the streaming control -------------------//
    if (ctrl_pkt_id_cmp(id, "rx_streaming") && data_len == sizeof(uint32_t)*5){
        int on_p =              get_int32(data + 0*sizeof(uint32_t));
        int ip_addr =           get_int32(data + 1*sizeof(uint32_t));
        int port =              get_int32(data + 2*sizeof(uint32_t));
        int samples_per_frame = get_int32(data + 3*sizeof(uint32_t));
        int rxdspno =           get_int32(data + 4*sizeof(uint32_t));
        struct in_addr addr = { ip_addr };
        rx_streaming_cmd(rxdspno, on_p, addr, port, samples_per_frame);
        send_ctrl_pkt(id, NULL, 0); //send empty response, so the host knows we got it
        return;
    }
    printf("Error: Unknown Ctrl Packet %s\n", id);
}


static void
beam_former_init(void)
{
  // init beam-former gain
  sr_beam_former->input[0].i_gain = 16700000;	// max Q1.24
  sr_beam_former->input[0].q_gain = 0x000000;
  sr_beam_former->input[1].i_gain = 0x000000;
  sr_beam_former->input[1].q_gain = 0x000000;
  sr_beam_former->input[2].i_gain = 0x000000;
  sr_beam_former->input[2].q_gain = 0x000000;
  sr_beam_former->input[3].i_gain = 0x000000;
  sr_beam_former->input[3].q_gain = 0x000000;
}

static void
half_band_init(void)
{
  // first (fast) half band
  sr_ddc->half_band[0] = 0x80000000;	// start load of filter 1
	// coeff for filter 1 (18 bits)
  sr_ddc->half_band[0] = -20743 & 0x7fffffff;
  sr_ddc->half_band[0] = 80795;
  sr_ddc->half_band[0] = -2178 & 0x7fffffff;
  sr_ddc->half_band[0] = 7247;
  sr_ddc->half_band[0] = -53 & 0x7fffffff;
  sr_ddc->half_band[0] = 466;
  sr_ddc->half_band[0] = 131071;	// center tap

  // second (slower) half band
  sr_ddc->half_band[1] = 0x80000000;	// start load of filter 2
  sr_ddc->half_band[1] = -9070 & 0x7fffffff;		// coeff for filter 2 (18 bits)
  sr_ddc->half_band[1] = 14537;
  sr_ddc->half_band[1] = -26475 & 0x7fffffff;
  sr_ddc->half_band[1] = 82988;
  sr_ddc->half_band[1] = -1411 & 0x7fffffff;
  sr_ddc->half_band[1] = 2364;
  sr_ddc->half_band[1] = -3775 & 0x7fffffff;
  sr_ddc->half_band[1] = 5862;
  sr_ddc->half_band[1] = -51 & 0x7fffffff;
  sr_ddc->half_band[1] = 167;
  sr_ddc->half_band[1] = -393 & 0x7fffffff;
  sr_ddc->half_band[1] = 785;
  sr_ddc->half_band[1] = 131071;
}

